import java.io.*;
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.text.*;

fun main(String[] args){
    Console2();
}

class Console2 : JFrame, WindowListener, Runnable {

  private JTextPane textArea;
  private Thread stdOutReader;
  private Thread stdErrReader;
  private boolean stopThreads;
  private final PipedInputStream stdOutPin = PipedInputStream();
  private final PipedInputStream stdErrPin = PipedInputStream();
  private StyledDocument doc;
  private Style style;

  constructor() {

    // The area to which the output will be send to
    textArea = JTextPane();
    textArea.setEditable(false);
    textArea.setBackground(Color.WHITE);
    doc = (StyledDocument) textArea.getDocument();
    style = doc.addStyle("ConsoleStyle", null);
    StyleConstants.setFontFamily(style, "MonoSpaced");
    StyleConstants.setFontSize(style, 12);
    setTitle("Console");
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    Dimension frameSize = Dimension((int)screenSize.width / 3, (int)screenSize.height / 4);
    int x = (int)frameSize.width / 20;
    int y = (int)frameSize.height / 20;
    setBounds(x, y, (int)frameSize.width, (int)frameSize.height);

    getContentPane().add(JScrollPane(textArea), BorderLayout.CENTER);
    setVisible(true);

    addWindowListener(this);

    try {
      PipedOutputStream stdOutPos = PipedOutputStream(this.stdOutPin);
      System.setOut(PrintStream(stdOutPos, true));
    } catch (java.io.IOException io) {
      textArea.setText("Couldn't redirect STDOUT to this console\n" + io.message);
    } catch (SecurityException se) {
      textArea.setText("Couldn't redirect STDOUT to this console\n" + se.message);
    }

    try {
      PipedOutputStream stdErrPos = PipedOutputStream(this.stdErrPin);
      System.setErr(PrintStream(stdErrPos, true));
    } catch (java.io.IOException io) {
      textArea.setText("Couldn't redirect STDERR to this console\n" + io.message);
    } catch (SecurityException se) {
      textArea.setText("Couldn't redirect STDERR to this console\n" + se.message);
    }

    stopThreads = false;

    stdOutReader = Thread(this);
    stdOutReader.setDaemon(true);
    stdOutReader.start();

    stdErrReader = Thread(this);
    stdErrReader.setDaemon(true);
    stdErrReader.start;
  }

  fun synchronized void windowClosed(WindowEvent evt) {
    stopThreads = true;
    this.notifyAll();

    try {
      stdOutReader.join(1000);
      stdOutPin.close();
    };

    try {
      stdErrReader.join(1000);
      stdErrPin.close();
    }
  }

  fun synchronized void windowClosing(WindowEvent evt) {
    setVisible(false);
    dispose();
  }

  fun synchronized void run() {
    try {
      while (Thread.currentThread() == stdOutReader) {
        try this.wait(100);
        if (stdOutPin.available() != 0) {
          String input = this.readLine(stdOutPin);
          StyleConstants.setForeground(style, Color.black);
          doc.insertString(doc.getLength(), input, style);
          textArea.setCaretPosition(textArea.document.length);
        }
        if (stopThreads) {
          return;
        }
      }

      while (Thread.currentThread == stdErrReader) {
        try this.wait(100);
        if (stdErrPin.available != 0) {
          String input = this.readLine(stdErrPin);
          StyleConstants.setForeground(style, Color.red);
          doc.insertString(doc.length, input, style);
          textArea.setCaretPosition(textArea.document.length);
        }
        if (stopThreads) {
          return;
        }
      }
    } catch (Exception e) {
      textArea.setText("\nConsole reports an Internal error.");
      textArea.setText("The error is: " + e);
    }
  }

  fun private synchronized String readLine(PipedInputStream inStream) {
    String input = "";
    while(true) {
      int available = inStream.available();
      if (available == 0) {
        break;
      }
      byte[] b = byte[available]();
      inStream.read(b);
      input = input+String(b, 0, b.length);
      if(!((!input.endsWith("\n") && !input.endsWith("\r\n") && !stopThreads))){
        break;
      }
    };
    return input;
  }

  fun void windowOpened(WindowEvent e) {}

  fun void windowIconified(WindowEvent e) {}

  fun void windowDeiconified(WindowEvent e) {}

  fun void windowActivated(WindowEvent e) {}

  fun void windowDeactivated(WindowEvent e) {}

}
