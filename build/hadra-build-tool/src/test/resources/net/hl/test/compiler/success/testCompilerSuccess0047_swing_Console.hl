fun main(String[] args){
}
class Console2 : JFrame, WindowListener, Runnable {

  private JTextPane textArea;
  private Thread stdOutReader;
  private Thread stdErrReader;
  private boolean stopThreads;
  private final PipedInputStream stdOutPin = PipedInputStream();
  private final PipedInputStream stdErrPin = PipedInputStream();
  //Used to print error messages in red
  private StyledDocument doc;
  private Style style;

  /** Initializes a new console */
  constructor() {

    // The area to which the output will be send to
    textArea = JTextPane();
    textArea.setEditable(false);
    textArea.setBackground(Color.WHITE);
    doc = (StyledDocument) textArea.getDocument();
    style = doc.addStyle("ConsoleStyle", null);
    StyleConstants.setFontFamily(style, "MonoSpaced");
    StyleConstants.setFontSize(style, 12);

    // Main frame to which the text area will be added to, along with scroll bars
    setTitle("Console");
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    Dimension frameSize = Dimension((int)screenSize.width / 3, (int)screenSize.height / 4);
    int x = (int)frameSize.width / 20;
    int y = (int)frameSize.height / 20;
    setBounds(x, y, (int)frameSize.width, (int)frameSize.height);

    getContentPane().add(JScrollPane(textArea), BorderLayout.CENTER);
    setVisible(true);

    addWindowListener(this);

    try {
      PipedOutputStream stdOutPos = PipedOutputStream(this.stdOutPin);
      System.setOut(PrintStream(stdOutPos, true));
    } catch (java.io.IOException io) {
      textArea.setText("Couldn't redirect STDOUT to this console\n" + io.getMessage());
    } catch (SecurityException se) {
      textArea.setText("Couldn't redirect STDOUT to this console\n" + se.getMessage());
    }

    try {
      PipedOutputStream stdErrPos = PipedOutputStream(this.stdErrPin);
      System.setErr(PrintStream(stdErrPos, true));
    } catch (java.io.IOException io) {
      textArea.setText("Couldn't redirect STDERR to this console\n" + io.getMessage());
    } catch (SecurityException se) {
      textArea.setText("Couldn't redirect STDERR to this console\n" + se.getMessage());
    }

    stopThreads = false; // Will be set to true at closing time. This will stop the threads

    // Starting two threads to read the PipedInputStreams
    stdOutReader = Thread(this);
    stdOutReader.setDaemon(true);
    stdOutReader.start();

    stdErrReader = Thread(this);
    stdErrReader.setDaemon(true);
    stdErrReader.start;
  }

  /**
   * Closes the window and stops the "stdOutReader" threads
   *
   * @param evt WindowEvent
   */
  fun synchronized void windowClosed(WindowEvent evt) {

    // Notify the threads that they must stop
    stopThreads = true;
    this.notifyAll();

    try {
      stdOutReader.join(1000);
      stdOutPin.close();
    };

    try {
      stdErrReader.join(1000);
      stdErrPin.close();
    }
  }

  /** Close the window */
  fun synchronized void windowClosing(WindowEvent evt) {
    setVisible(false);
    dispose();
  }

  /** The real work... */
  fun synchronized void run() {
    try {
      while (Thread.currentThread() == stdOutReader) {
        try this.wait(100);
        if (stdOutPin.available() != 0) {
          String input = this.readLine(stdOutPin);
          StyleConstants.setForeground(style, Color.black);
          doc.insertString(doc.getLength(), input, style);
          // Make sure the last line is always visible
          textArea.setCaretPosition(textArea.getDocument().getLength());
        }
        if (stopThreads) {
          return;
        }
      }

      while (Thread.currentThread() == stdErrReader) {
        try this.wait(100);
        if (stdErrPin.available() != 0) {
          String input = this.readLine(stdErrPin);
          StyleConstants.setForeground(style, Color.red);
          doc.insertString(doc.getLength(), input, style);
          // Make sure the last line is always visible
          textArea.setCaretPosition(textArea.getDocument().getLength());
        }
        if (stopThreads) {
          return;
        }
      }
    } catch (Exception e) {
      textArea.setText("\nConsole reports an Internal error.");
      textArea.setText("The error is: " + e);
    }
  }

  fun private /*synchronized*/ String readLine(PipedInputStream inStream) {
    String input = "";
    while(true) {
      int available = inStream.available();
      if (available == 0) {
        break;
      }
      byte[] b = byte[available]();
      inStream.read(b);
      input = input+String(b, 0, b.length);
      if(!((!input.endsWith("\n") && !input.endsWith("\r\n") && !stopThreads))){
        break;
      }
    };
    return input;
  }

  //These methods must implement these inherited abstract methods from WindowListener
  fun void windowOpened(WindowEvent e) {}

  fun void windowIconified(WindowEvent e) {}

  fun void windowDeiconified(WindowEvent e) {}

  fun void windowActivated(WindowEvent e) {}

  fun void windowDeactivated(WindowEvent e) {}

}
